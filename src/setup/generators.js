import fs from 'fs-extra';
import path from 'path';

/**
 * Generate .env file content from configuration
 * @param {Object} config - Configuration object
 * @returns {string} - .env file content
 */
export function generateEnvFile(config) {
  const envContent = `# OpenAI Configuration
OPENAI_API_KEY=${config.apiKey}

# Cost Management (USD)
DAILY_COST_LIMIT=${config.dailyCostLimit}
TASK_COST_LIMIT=${config.taskCostLimit}

# AI Behavior Settings
DEFAULT_REASONING_EFFORT=${config.reasoningEffort}
DEFAULT_VERBOSITY=${config.verbosity}

# Fallback Model Configuration
FALLBACK_MODEL=${config.fallbackModel}

# Additional Settings
DEFAULT_TEMPERATURE=0.7
LOG_LEVEL=info

# Generated by GPT-5 MCP Setup Wizard on ${new Date().toISOString()}
`;

  return envContent;
}

/**
 * Generate Claude Desktop configuration JSON
 * @param {string} projectPath - Absolute path to the project directory
 * @param {Object} config - Configuration object
 * @returns {Object} - Claude Desktop configuration object
 */
export function generateClaudeDesktopConfig(projectPath, config) {
  const absoluteIndexPath = path.join(projectPath, 'dist', 'index.js');
  const absoluteEnvPath = path.join(projectPath, '.env');
  
  return {
    mcpServers: {
      gpt5: {
        command: "node",
        args: [absoluteIndexPath],
        env: {
          OPENAI_API_KEY: config.apiKey,
          DAILY_COST_LIMIT: config.dailyCostLimit,
          TASK_COST_LIMIT: config.taskCostLimit,
          DEFAULT_REASONING_EFFORT: config.reasoningEffort,
          DEFAULT_VERBOSITY: config.verbosity,
          FALLBACK_MODEL: config.fallbackModel,
          DEFAULT_TEMPERATURE: "0.7",
          LOG_LEVEL: "info"
        }
      }
    }
  };
}

/**
 * Generate Claude Code CLI commands
 * @param {string} projectPath - Absolute path to the project directory
 * @param {Object} config - Configuration object
 * @returns {string[]} - Array of CLI commands
 */
export function generateClaudeCodeCommands(projectPath, config) {
  const absoluteIndexPath = path.join(projectPath, 'dist', 'index.js');
  const absoluteEnvPath = path.join(projectPath, '.env');
  
  // Option 1: Using individual environment variables
  const envVarCommand = `claude mcp add gpt5 \\
  --env OPENAI_API_KEY=${config.apiKey} \\
  --env DAILY_COST_LIMIT=${config.dailyCostLimit} \\
  --env TASK_COST_LIMIT=${config.taskCostLimit} \\
  --env DEFAULT_REASONING_EFFORT=${config.reasoningEffort} \\
  --env DEFAULT_VERBOSITY=${config.verbosity} \\
  --env FALLBACK_MODEL=${config.fallbackModel} \\
  --env DEFAULT_TEMPERATURE=0.7 \\
  --env LOG_LEVEL=info \\
  -- node "${absoluteIndexPath}"`;
  
  // Option 2: Using .env file (recommended)
  const envFileCommand = `claude mcp add gpt5 \\
  --env-file "${absoluteEnvPath}" \\
  -- node "${absoluteIndexPath}"`;
  
  return [envVarCommand, envFileCommand];
}

/**
 * Write .env file to disk
 * @param {string} projectPath - Project directory path
 * @param {string} content - .env file content
 * @param {boolean} backup - Whether to create backup of existing file
 */
export async function writeEnvFile(projectPath, content, backup = true) {
  const envPath = path.join(projectPath, '.env');
  
  // Create backup if file exists and backup is requested
  if (backup && await fs.pathExists(envPath)) {
    const backupPath = path.join(projectPath, '.env.backup');
    await fs.copy(envPath, backupPath);
    console.log(`✅ Backup created: .env.backup`);
  }
  
  // Write new .env file
  await fs.writeFile(envPath, content, 'utf8');
  console.log(`✅ Configuration written to: .env`);
}

/**
 * Write Claude Desktop configuration to user's config directory
 * @param {Object} config - Claude Desktop configuration object
 * @param {boolean} dryRun - Whether this is a dry run (don't actually write)
 * @returns {Promise<string>} - Path where config was written or would be written
 */
export async function writeClaudeDesktopConfig(config, dryRun = false) {
  const os = process.platform;
  let configDir;
  
  // Determine config directory based on OS
  switch (os) {
    case 'darwin': // macOS
      configDir = path.join(process.env.HOME, 'Library', 'Application Support', 'Claude');
      break;
    case 'win32': // Windows
      configDir = path.join(process.env.APPDATA, 'Claude');
      break;
    case 'linux': // Linux
      configDir = path.join(process.env.HOME, '.config', 'Claude');
      break;
    default:
      throw new Error(`Unsupported operating system: ${os}`);
  }
  
  const configPath = path.join(configDir, 'claude_desktop_config.json');
  
  if (dryRun) {
    return configPath;
  }
  
  // Ensure config directory exists
  await fs.ensureDir(configDir);
  
  // Read existing config or create new one
  let existingConfig = {};
  if (await fs.pathExists(configPath)) {
    try {
      existingConfig = await fs.readJson(configPath);
    } catch (error) {
      console.warn(`Warning: Could not parse existing config, creating new one`);
    }
  }
  
  // Merge configurations (add our server to existing servers)
  const mergedConfig = {
    ...existingConfig,
    mcpServers: {
      ...existingConfig.mcpServers,
      ...config.mcpServers
    }
  };
  
  // Write merged configuration
  await fs.writeJson(configPath, mergedConfig, { spaces: 2 });
  
  return configPath;
}

/**
 * Get project root directory path
 * @returns {string} - Absolute path to project root
 */
export function getProjectPath() {
  // Get the directory containing this script, then go up to project root
  const currentDir = process.cwd();
  
  // Verify this is the correct project by checking for key files
  const keyFiles = ['package.json', 'src/index.ts', '.env.example'];
  const isProjectRoot = keyFiles.every(file => 
    fs.existsSync(path.join(currentDir, file))
  );
  
  if (!isProjectRoot) {
    throw new Error('Please run this setup from the project root directory');
  }
  
  return currentDir;
}

/**
 * Ensure the project is built before generating paths
 * @param {string} projectPath - Project root path
 * @returns {Promise<boolean>} - Whether build exists
 */
export async function ensureProjectBuilt(projectPath) {
  const distPath = path.join(projectPath, 'dist', 'index.js');
  return await fs.pathExists(distPath);
}

/**
 * Generate all configuration outputs
 * @param {Object} config - User configuration
 * @returns {Promise<Object>} - Generated configurations
 */
export async function generateAllConfigurations(config) {
  const projectPath = getProjectPath();
  
  // Check if project is built
  const isBuilt = await ensureProjectBuilt(projectPath);
  if (!isBuilt) {
    throw new Error('Project must be built first. Run "npm run build" before setup.');
  }
  
  // Generate all configurations
  const envContent = generateEnvFile(config);
  const desktopConfig = generateClaudeDesktopConfig(projectPath, config);
  const cliCommands = generateClaudeCodeCommands(projectPath, config);
  
  return {
    projectPath,
    envContent,
    mcpConfig: {
      desktop: desktopConfig,
      cli: cliCommands
    }
  };
}

/**
 * Write all configuration files
 * @param {Object} config - User configuration
 * @param {Object} generated - Generated configurations
 * @param {Object} options - Write options
 */
export async function writeAllConfigurations(config, generated, options = {}) {
  const { backup = true, writeDesktopConfig = true } = options;
  
  try {
    // Write .env file
    await writeEnvFile(generated.projectPath, generated.envContent, backup);
    
    // Write Claude Desktop config if requested
    if (writeDesktopConfig) {
      const configPath = await writeClaudeDesktopConfig(generated.mcpConfig.desktop);
      console.log(`✅ Claude Desktop config updated: ${configPath}`);
    }
    
    console.log(`✅ Setup completed successfully!`);
    
    return true;
  } catch (error) {
    console.error(`❌ Error writing configurations: ${error.message}`);
    return false;
  }
}